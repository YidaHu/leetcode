# ğŸ“– LeetCode æ ¸å¿ƒé¢˜å‹æ·±åº¦é€šå…³æ‰‹å†Œ (Top 20) - ç»ˆæè¯¦è§£ç‰ˆ

è¿™ä»½æ–‡æ¡£æ˜¯ä¸ºä½ é‡èº«å®šåˆ¶çš„**æ·±åº¦å¤ä¹ èµ„æ–™**ã€‚æ¯ä¸€é“é¢˜éƒ½åŒ…å«ï¼š
1.  **é€šä¿—æ¯”å–»**ï¼šç”¨ç”Ÿæ´»ä¸­çš„ä¾‹å­è®©ä½ ç§’æ‡‚ã€‚
2.  **æ ¸å¿ƒé€»è¾‘**ï¼šæ‹†è§£ç®—æ³•çš„æœ¬è´¨ã€‚
3.  **è¯¦ç»†ä»£ç **ï¼šå¯ä»¥ç›´æ¥èƒŒè¯µå¹¶åœ¨é¢è¯•ä¸­ä½¿ç”¨çš„å®Œæ•´ä»£ç ï¼Œé™„å¸¦è¯¦ç»†æ³¨é‡Šã€‚

---

## ç›®å½•

1.  [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](#1-3-æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²)
2.  [146. LRU ç¼“å­˜æœºåˆ¶](#2-146-lru-ç¼“å­˜æœºåˆ¶)
3.  [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](#3-25-k-ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨)
4.  [206. åè½¬é“¾è¡¨](#4-206-åè½¬é“¾è¡¨)
5.  [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](#5-215-æ•°ç»„ä¸­çš„ç¬¬kä¸ªæœ€å¤§å…ƒç´ )
6.  [15. ä¸‰æ•°ä¹‹å’Œ](#6-15-ä¸‰æ•°ä¹‹å’Œ)
7.  [103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå†](#7-103-äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå†)
8.  [200. å²›å±¿æ•°é‡](#8-200-å²›å±¿æ•°é‡)
9.  [33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„](#9-33-æœç´¢æ—‹è½¬æ’åºæ•°ç»„)
10. [121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](#10-121-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº)
11. [54. èºæ—‹çŸ©é˜µ](#11-54-èºæ—‹çŸ©é˜µ)
12. [42. æ¥é›¨æ°´](#12-42-æ¥é›¨æ°´)
13. [5. æœ€é•¿å›æ–‡å­ä¸²](#13-5-æœ€é•¿å›æ–‡å­ä¸²)
14. [236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#14-236-äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)
15. [1. ä¸¤æ•°ä¹‹å’Œ](#15-1-ä¸¤æ•°ä¹‹å’Œ)
16. [46. å…¨æ’åˆ—](#16-46-å…¨æ’åˆ—)
17. [53. æœ€å¤§å­æ•°ç»„å’Œ](#17-53-æœ€å¤§å­æ•°ç»„å’Œ)
18. [160. ç›¸äº¤é“¾è¡¨](#18-160-ç›¸äº¤é“¾è¡¨)
19. [31. ä¸‹ä¸€ä¸ªæ’åˆ—](#19-31-ä¸‹ä¸€ä¸ªæ’åˆ—)
20. [300. æœ€é•¿ä¸Šå‡å­åºåˆ—](#20-300-æœ€é•¿ä¸Šå‡å­åºåˆ—)

---

### 1. [3] æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šæ»‘åŠ¨çª—å£ (Sliding Window)

#### ğŸ’¡ é€šä¿—æ¯”å–»
æƒ³è±¡ä½ åœ¨æ‹‰ä¸€æ ¹**æ©¡çš®ç­‹**ï¼ˆçª—å£ï¼‰ã€‚
*   **å³è¾¹ (`right`)** æ‹¼å‘½å¾€å³æ‹‰ï¼Œæƒ³åŒ…ä½æ›´å¤šçš„å­—ç¬¦ã€‚
*   **å·¦è¾¹ (`left`)** æ˜¯å›ºå®šçš„ã€‚
*   ä¸€æ—¦å³è¾¹æ‹‰è¿›æ¥çš„å­—ç¬¦**åœ¨é‡Œé¢å·²ç»æœ‰äº†**ï¼ˆé‡å¤äº†ï¼‰ï¼Œæ©¡çš®ç­‹å°±ç»·ä¸ä½äº†ã€‚
*   è¿™æ—¶å€™ï¼Œ**å·¦è¾¹ (`left`)** åªèƒ½è¢«è¿«å¾€å³ç¼©ï¼Œç›´åˆ°æŠŠé‚£ä¸ªé‡å¤çš„å­—ç¬¦â€œåâ€å‡ºå»ä¸ºæ­¢ï¼Œç„¶åå³è¾¹æ‰èƒ½ç»§ç»­å¾€å³æ‹‰ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        window = set() # ç”¨é›†åˆè®°å½•çª—å£é‡Œæœ‰å“ªäº›å­—ç¬¦
        left = 0
        max_len = 0
        
        for right in range(len(s)):
            # å¦‚æœå³è¾¹è¿›æ¥çš„å­—ç¬¦ s[right] å·²ç»åœ¨çª—å£é‡Œäº†ï¼Œè¯´æ˜é‡å¤äº†
            # å·¦è¾¹å°±è¦ä¸€ç›´ç¼©ï¼Œç›´åˆ°æŠŠé‚£ä¸ªé‡å¤çš„å­—ç¬¦ç§»å‡ºå»
            while s[right] in window:
                window.remove(s[left])
                left += 1
            
            # ç°åœ¨å®‰å…¨äº†ï¼ŒæŠŠæ–°å­—ç¬¦åŠ è¿›æ¥
            window.add(s[right])
            # æ›´æ–°æœ€å¤§é•¿åº¦
            max_len = max(max_len, right - left + 1)
            
        return max_len
```

---

### 2. [146] LRU ç¼“å­˜æœºåˆ¶
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šå“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨

#### ğŸ’¡ é€šä¿—æ¯”å–»
æƒ³è±¡ä¸€ä¸ª**ä¹¦æ¶**ï¼Œåªèƒ½æ”¾ K æœ¬ä¹¦ã€‚
*   **è§„åˆ™**ï¼šæ¯æ¬¡ä½ è¯»äº†ä¸€æœ¬ä¹¦ï¼Œä¸ç®¡å®ƒåŸæ¥åœ¨å“ªï¼Œéƒ½è¦æŠŠå®ƒæŠ½å‡ºæ¥ï¼Œæ’åˆ°**æœ€å‰é¢**ï¼ˆè¡¨ç¤ºæœ€è¿‘åˆšè¯»è¿‡ï¼‰ã€‚
*   **æ»¡äº†æ€ä¹ˆåŠ**ï¼šå¦‚æœä¹¦æ¶æ»¡äº†ï¼Œä½ è¦å¡æ–°ä¹¦ï¼Œå°±æŠŠ**æœ€åé¢**é‚£æœ¬ï¼ˆæœ€ä¹…æ²¡è¯»çš„ï¼‰æ‰”æ‰ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class DLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = {} # å“ˆå¸Œè¡¨ï¼škey -> Node
        self.head = DLinkedNode() # ä¼ªå¤´éƒ¨
        self.tail = DLinkedNode() # ä¼ªå°¾éƒ¨
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # å¦‚æœå­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨æ‰¾åˆ°èŠ‚ç‚¹
        node = self.cache[key]
        # ç„¶åæŠŠå®ƒç§»åˆ°å¤´éƒ¨ï¼ˆè¡¨ç¤ºæœ€è¿‘ç”¨è¿‡ï¼‰
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # å¦‚æœkeyå­˜åœ¨ï¼Œæ›´æ–°valueï¼Œå¹¶ç§»åˆ°å¤´éƒ¨
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
        else:
            # å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹
            node = DLinkedNode(key, value)
            self.cache[key] = node
            self.addToHead(node) # åŠ åˆ°å¤´éƒ¨
            self.size += 1
            if self.size > self.capacity:
                # å¦‚æœæ»¡äº†ï¼Œåˆ æ‰å°¾éƒ¨ï¼ˆæœ€ä¹…æ²¡ç”¨çš„ï¼‰
                removed = self.removeTail()
                self.cache.pop(removed.key) # åˆ«å¿˜äº†ä»å“ˆå¸Œè¡¨é‡Œä¹Ÿåˆ æ‰
                self.size -= 1

    # --- è¾…åŠ©å‡½æ•° ---
    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def removeTail(self):
        res = self.tail.prev
        self.removeNode(res)
        return res
```

---

### 3. [25] K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨
*   **éš¾åº¦**ï¼šå›°éš¾
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šé“¾è¡¨æ“ä½œ + é€’å½’/è¿­ä»£

#### ğŸ’¡ é€šä¿—æ¯”å–»
**åˆ‡é¦™è‚ **ã€‚
æŠŠä¸€é•¿ä¸²é¦™è‚ ï¼ŒæŒ‰æ¯ K ä¸ªåˆ‡ä¸€åˆ€ã€‚
åˆ‡ä¸‹æ¥çš„ä¸€æ®µï¼Œæ‹¿å»æ²¹é”…é‡Œç‚¸ä¸€ä¸‹ï¼ˆç¿»è½¬ï¼‰ã€‚
ç‚¸å¥½äº†å†æŒ‰åŸæ¥çš„é¡ºåºæ¥å›å»ã€‚
å¦‚æœæœ€åå‰©çš„ä¸€å°æ®µä¸å¤Ÿ K ä¸ªï¼Œå°±ä¸åˆ‡äº†ï¼Œç›´æ¥ç•™ç€ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # è¾…åŠ©å‡½æ•°ï¼šç¿»è½¬é“¾è¡¨
        def reverse(head):
            pre = None
            curr = head
            while curr:
                next_node = curr.next
                curr.next = pre
                pre = curr
                curr = next_node
            return pre

        dummy = ListNode(-1)
        dummy.next = head
        pre = dummy
        end = dummy
        
        while end.next:
            # 1. æ‰¾åˆ°è¿™ä¸€ç»„çš„ç»“å°¾
            for i in range(k):
                end = end.next
                if not end: return dummy.next # ä¸è¶³kä¸ªï¼Œç›´æ¥è¿”å›
            
            # 2. è®°å½•æ–­ç‚¹
            start = pre.next
            next_group = end.next
            
            # 3. åˆ‡æ–­
            end.next = None
            
            # 4. ç¿»è½¬è¿™ä¸€ç»„ï¼Œæ¥å› pre
            pre.next = reverse(start)
            
            # 5. è¿ä¸Šåé¢
            start.next = next_group
            
            # 6. é‡ç½®æŒ‡é’ˆ
            pre = start
            end = pre
            
        return dummy.next
```

---

### 4. [206] åè½¬é“¾è¡¨
*   **éš¾åº¦**ï¼šç®€å•
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šåŒæŒ‡é’ˆ

#### ğŸ’¡ é€šä¿—æ¯”å–»
**å‘åè½¬**ã€‚
ä¸€æ’äººæ‰‹æ­è‚©è†€ã€‚
ä½ ï¼ˆCurrï¼‰æ¾å¼€å‰é¢äººï¼ˆNextï¼‰çš„è‚©è†€ï¼Œè½¬èº«æ­ä½åé¢äººï¼ˆPreï¼‰çš„è‚©è†€ã€‚
ç„¶åå¤§å®¶æ•´ä½“å¾€å‰æŒªä¸€æ­¥ï¼Œé‡å¤è¿™ä¸ªåŠ¨ä½œã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        curr = head
        while curr:
            next_node = curr.next # 1. å­˜ä¸‹ä¸ª
            curr.next = pre       # 2. æŒ‡å‰ä¸ª
            pre = curr            # 3. æŒªå‰ä¸ª
            curr = next_node      # 4. æŒªä¸‹ä¸ª
        return pre
```

---

### 5. [215] æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šå † (Heap)

#### ğŸ’¡ é€šä¿—æ¯”å–»
**VIP ä¿±ä¹éƒ¨**ã€‚
ä¿±ä¹éƒ¨åªæœ‰ K ä¸ªåº§ä½ï¼ˆå°é¡¶å †ï¼‰ã€‚
æ‰€æœ‰äººï¼ˆæ•°ç»„å…ƒç´ ï¼‰æ’é˜Ÿè¿›åœºã€‚
*   å¦‚æœä¿±ä¹éƒ¨æ²¡æ»¡ï¼Œç›´æ¥è¿›ã€‚
*   å¦‚æœæ»¡äº†ï¼Œä½ æ¯”é‡Œé¢**æœ€å¼±**ï¼ˆå †é¡¶ï¼‰çš„é‚£ä¸ªäººå¼ºï¼Œå°±æŠŠä»–è¸¢å‡ºå»ï¼Œä½ è¿›å»ã€‚
*   å¦‚æœæ¯”æœ€å¼±çš„è¿˜å¼±ï¼Œä½ å°±åˆ«è¿›äº†ã€‚
æœ€åï¼Œç•™åœ¨ä¿±ä¹éƒ¨é‡Œçš„ K ä¸ªäººå°±æ˜¯æœ€å¼ºçš„ K ä¸ªï¼Œè€Œ**æœ€å¼±çš„é‚£ä¸ªï¼ˆå †é¡¶ï¼‰**å°±æ˜¯ç¬¬ K å¼ºçš„äººã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
import heapq
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = []
        for num in nums:
            heapq.heappush(heap, num) # è¿›å †
            if len(heap) > k:
                heapq.heappop(heap)   # å †æ»¡äº†ï¼Œè¸¢æ‰æœ€å°çš„
        return heap[0] # å †é¡¶å°±æ˜¯ç¬¬ K å¤§
```

---

### 6. [15] ä¸‰æ•°ä¹‹å’Œ
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šæ’åº + åŒæŒ‡é’ˆ

#### ğŸ’¡ é€šä¿—æ¯”å–»
**å¤©å¹³é…é‡**ã€‚
å…ˆç»™æ‰€æœ‰ç ç æ’ä¸ªåºï¼ˆä»å°åˆ°å¤§ï¼‰ã€‚
å…ˆé€‰å®šä¸€ä¸ªç ç  `A` æ”¾å·¦è¾¹ã€‚
ç„¶ååœ¨å‰©ä¸‹çš„ç ç é‡Œæ‰¾ä¸¤ä¸ª `B` å’Œ `C`ï¼Œä½¿å¾— `A+B+C = 0`ã€‚
å› ä¸ºæœ‰åºï¼Œå¦‚æœè½»äº†ï¼Œ`B` å°±é€‰å¤§ä¸€ç‚¹çš„ï¼›å¦‚æœé‡äº†ï¼Œ`C` å°±é€‰å°ä¸€ç‚¹çš„ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort() # å¿…é¡»æ’åº
        res = []
        n = len(nums)
        
        for i in range(n - 2):
            if nums[i] > 0: break # ä¼˜åŒ–ï¼šæœ€å°çš„éƒ½å¤§äº0ï¼Œåé¢æ²¡æˆäº†
            if i > 0 and nums[i] == nums[i-1]: continue # å»é‡ï¼šè·³è¿‡é‡å¤çš„è€å¤§
            
            left, right = i + 1, n - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total < 0:
                    left += 1
                elif total > 0:
                    right -= 1
                else:
                    res.append([nums[i], nums[left], nums[right]])
                    # å»é‡ï¼šè·³è¿‡é‡å¤çš„è€äºŒå’Œè€ä¸‰
                    while left < right and nums[left] == nums[left+1]: left += 1
                    while left < right and nums[right] == nums[right-1]: right -= 1
                    left += 1
                    right -= 1
        return res
```

---

### 7. [103] äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå†
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šBFS + æ ‡å¿—ä½

#### ğŸ’¡ é€šä¿—æ¯”å–»
**æ‰“å°æœº**ã€‚
æ‰“å°æœºæ‰“å°ç¬¬ä¸€è¡Œæ˜¯ä»å·¦åˆ°å³ã€‚
æ‰“å°ç¬¬äºŒè¡Œæ˜¯ä»å³åˆ°å·¦ï¼ˆä¸ºäº†çœå¢¨ç›’ç§»åŠ¨çš„æ—¶é—´ï¼‰ã€‚
æˆ‘ä»¬ç”¨ BFS æ‹¿å‡ºæ¥çš„é¡ºåºæ°¸è¿œæ˜¯ä»å·¦åˆ°å³ï¼Œåªæ˜¯åœ¨**å­˜å…¥ç»“æœ**çš„æ—¶å€™ï¼Œå¦‚æœæ˜¯å¶æ•°è¡Œï¼Œå°±æ‰‹åŠ¨ç¿»è½¬ä¸€ä¸‹ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        queue = collections.deque([root])
        res = []
        is_left = True # æ–¹å‘æ ‡å¿—
        
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            
            # å¦‚æœæ˜¯ä»å³å¾€å·¦ï¼Œç¿»è½¬ä¸€ä¸‹
            if not is_left:
                level.reverse()
            
            res.append(level)
            is_left = not is_left # åˆ‡æ¢æ–¹å‘
            
        return res
```

---

### 8. [200] å²›å±¿æ•°é‡
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šDFS (æ²‰å²›æ€æƒ³)

#### ğŸ’¡ é€šä¿—æ¯”å–»
**ç—…æ¯’æ„ŸæŸ“**ï¼ˆæˆ–è€…ç‚¸å²›ï¼‰ã€‚
ä½ éå†åœ°å›¾ï¼Œä¸€æ—¦å‘ç°ä¸€å—é™†åœ° `1`ï¼Œè¯´æ˜å‘ç°äº†ä¸€ä¸ªæ–°å²›å±¿ï¼Œè®¡æ•°å™¨ +1ã€‚
ç„¶åä½ ç«‹åˆ»é‡Šæ”¾ç—…æ¯’ï¼ˆDFSï¼‰ï¼ŒæŠŠè¿™å—é™†åœ°ä»¥åŠå’Œå®ƒç›¸è¿çš„æ‰€æœ‰é™†åœ°å…¨éƒ¨æ„ŸæŸ“æˆ `0`ã€‚
è¿™æ ·ä¸‹æ¬¡éå†åˆ°å®ƒä»¬æ—¶ï¼Œå°±ä¸ä¼šé‡å¤è®¡æ•°äº†ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid: return 0
        
        def dfs(i, j):
            # è¶Šç•Œæˆ–è€…ä¸æ˜¯é™†åœ°ï¼Œç›´æ¥è¿”å›
            if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1'):
                return
            
            grid[i][j] = '0' # æ²‰å²›ï¼šæ ‡è®°ä¸ºå·²è®¿é—®
            
            # å‘å››ä¸ªæ–¹å‘æ‰©æ•£
            dfs(i+1, j)
            dfs(i-1, j)
            dfs(i, j+1)
            dfs(i, j-1)
            
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    count += 1 # å‘ç°æ–°å¤§é™†
                    dfs(i, j)  # ç‚¸æ²‰å®ƒ
        return count
```

---

### 9. [33] æœç´¢æ—‹è½¬æ’åºæ•°ç»„
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šäºŒåˆ†æŸ¥æ‰¾

#### ğŸ’¡ é€šä¿—æ¯”å–»
**æ–­æ‰çš„å°ºå­**ã€‚
ä¸€æŠŠå°ºå­ `[0, 1, 2, 4, 5, 6, 7]` è¢«æ°æ–­äº†ï¼Œæ‹¼æˆäº† `[4, 5, 6, 7, 0, 1, 2]`ã€‚
ä½ ä»ä¸­é—´åˆ‡ä¸€åˆ€ï¼Œ**ä¸€å®šæœ‰ä¸€åŠæ˜¯å®Œå¥½çš„ï¼ˆæœ‰åºçš„ï¼‰ï¼Œå¦ä¸€åŠæ˜¯æ–­çš„**ã€‚
æˆ‘ä»¬åˆ©ç”¨â€œå¥½â€çš„é‚£ä¸€åŠæ¥åˆ¤æ–­ç›®æ ‡å€¼åœ¨å“ªã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            
            # åˆ¤æ–­å“ªè¾¹æ˜¯æœ‰åºçš„
            if nums[left] <= nums[mid]: # å·¦è¾¹æœ‰åº
                if nums[left] <= target < nums[mid]: # ç›®æ ‡åœ¨å·¦è¾¹èŒƒå›´å†…
                    right = mid - 1
                else:
                    left = mid + 1
            else: # å³è¾¹æœ‰åº
                if nums[mid] < target <= nums[right]: # ç›®æ ‡åœ¨å³è¾¹èŒƒå›´å†…
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

---

### 10. [121] ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº
*   **éš¾åº¦**ï¼šç®€å•
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šè´ªå¿ƒ / ä¸€æ¬¡éå†

#### ğŸ’¡ é€šä¿—æ¯”å–»
**æ—¶å…‰æœº**ã€‚
ä½ å›åˆ°äº†è¿‡å»ï¼Œæ‰‹é‡Œåªæœ‰ä¸€æ¬¡ä¹°å…¥å’Œä¸€æ¬¡å–å‡ºçš„æœºä¼šã€‚
ä½ åªéœ€è¦è®°ä½ä¸¤ä¸ªæ•°å­—ï¼š
1.  **å†å²æœ€ä½ä»·**ï¼ˆæˆ‘è§è¿‡çš„æœ€ä¾¿å®œçš„è‚¡ç¥¨ï¼‰ã€‚
2.  **æœ€å¤§åˆ©æ¶¦**ï¼ˆå¦‚æœæˆ‘åœ¨é‚£ä¸ªæœ€ä½ä»·ä¹°å…¥ï¼Œä»Šå¤©å–å‡ºï¼Œèƒ½èµšå¤šå°‘ï¼‰ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = float('inf')
        max_profit = 0
        
        for price in prices:
            if price < min_price:
                min_price = price # å‘ç°æ›´ä½çš„ä»·æ ¼ï¼Œæ›´æ–°æœ€ä½ä»·
            elif price - min_price > max_profit:
                max_profit = price - min_price # å‘ç°æ›´é«˜çš„åˆ©æ¶¦ï¼Œæ›´æ–°åˆ©æ¶¦
                
        return max_profit
```

---

### 11. [54] èºæ—‹çŸ©é˜µ
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šæ¨¡æ‹Ÿ

#### ğŸ’¡ é€šä¿—æ¯”å–»
**è´ªåƒè›‡**ã€‚
è›‡åœ¨ä¸€ä¸ªçŸ©å½¢é‡Œç»•åœˆåœˆã€‚
æ’åˆ°å¢™ï¼ˆè¾¹ç•Œï¼‰å°±å³è½¬ã€‚
æ¯èµ°å®Œä¸€åœˆï¼Œå¢™å£å°±å¾€é‡Œç¼©ä¸€åœˆï¼ˆå‰¥æ´‹è‘±ï¼‰ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix: return []
        l, r, t, b = 0, len(matrix[0]) - 1, 0, len(matrix) - 1
        res = []
        
        while True:
            # å·¦ -> å³
            for i in range(l, r + 1): res.append(matrix[t][i])
            t += 1
            if t > b: break
            
            # ä¸Š -> ä¸‹
            for i in range(t, b + 1): res.append(matrix[i][r])
            r -= 1
            if l > r: break 
            
            # å³ -> å·¦
            for i in range(r, l - 1, -1): res.append(matrix[b][i])
            b -= 1
            if t > b: break
            
            # ä¸‹ -> ä¸Š
            for i in range(b, t - 1, -1): res.append(matrix[i][l])
            l += 1
            if l > r: break
            
        return res
```

---

### 12. [42] æ¥é›¨æ°´
*   **éš¾åº¦**ï¼šå›°éš¾
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šåŒæŒ‡é’ˆ

#### ğŸ’¡ é€šä¿—æ¯”å–»
**æœ¨æ¡¶æ•ˆåº”**ã€‚
ç«™åœ¨ä»»ä½•ä¸€ä¸ªä½ç½®ï¼Œå¤´é¡¶ä¸Šèƒ½å­˜å¤šå°‘æ°´ï¼Œå–å†³äº**å·¦è¾¹æœ€é«˜çš„å¢™**å’Œ**å³è¾¹æœ€é«˜çš„å¢™**ï¼Œè¿™ä¸¤å µå¢™é‡Œ**è¾ƒçŸ®**çš„é‚£ä¸€ä¸ªã€‚
`æ°´é‡ = min(å·¦é«˜, å³é«˜) - è‡ªå·±çš„é«˜åº¦`ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        left_max, right_max = 0, 0
        ans = 0
        
        while left < right:
            # è°çŸ®è°åŠ¨ï¼Œå› ä¸ºçŸ­æ¿å†³å®šæ°´é‡
            if height[left] < height[right]:
                if height[left] >= left_max:
                    left_max = height[left] # æ›´æ–°å·¦è¾¹æœ€é«˜
                else:
                    ans += left_max - height[left] # ç»“ç®—æ°´é‡
                left += 1
            else:
                if height[right] >= right_max:
                    right_max = height[right] # æ›´æ–°å³è¾¹æœ€é«˜
                else:
                    ans += right_max - height[right] # ç»“ç®—æ°´é‡
                right -= 1
        return ans
```

---

### 13. [5] æœ€é•¿å›æ–‡å­ä¸²
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šä¸­å¿ƒæ‰©æ•£æ³•

#### ğŸ’¡ é€šä¿—æ¯”å–»
**æ°´æ³¢çº¹**ã€‚
å›æ–‡ä¸²æ˜¯ä¸­å¿ƒå¯¹ç§°çš„ã€‚
æˆ‘ä»¬æŠŠæ¯ä¸ªå­—ç¬¦éƒ½å½“æˆâ€œéœ‡æºâ€ï¼Œå‘ä¸¤è¾¹æ‰©æ•£ã€‚
åªè¦å·¦è¾¹ç­‰äºå³è¾¹ï¼Œæ³¢çº¹å°±ç»§ç»­æ‰©ï¼›å¦åˆ™åœæ­¢ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ""
        for i in range(len(s)):
            # å¥‡æ•°é•¿åº¦ï¼šä»¥ s[i] ä¸ºä¸­å¿ƒ (å¦‚ "aba")
            s1 = self.expand(s, i, i)
            # å¶æ•°é•¿åº¦ï¼šä»¥ s[i], s[i+1] ä¸ºä¸­å¿ƒ (å¦‚ "abba")
            s2 = self.expand(s, i, i + 1)
            
            # æ›´æ–°æœ€é•¿çš„
            res = max(res, s1, s2, key=len)
        return res
    
    def expand(self, s, left, right):
        # å‘ä¸¤è¾¹æ‰©æ•£
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        # æ³¨æ„ï¼šè·³å‡ºå¾ªç¯æ—¶ï¼Œleftå’Œrightå·²ç»ä¸æ»¡è¶³æ¡ä»¶äº†ï¼Œæ‰€ä»¥è¦å›é€€
        return s[left + 1 : right]
```

---

### 14. [236] äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šé€’å½’ (ååºéå†)

#### ğŸ’¡ é€šä¿—æ¯”å–»
**å¯»äººå¯äº‹**ã€‚
ä½ åœ¨å…¬å¸ï¼ˆæ ‘ï¼‰é‡Œæ‰¾ä¸¤ä¸ªäºº P å’Œ Qã€‚
ä½ é—®ä½ çš„ä¸‹å±ï¼ˆå­èŠ‚ç‚¹ï¼‰ï¼šâ€œä½ é‚£è¾¹çœ‹åˆ° P æˆ– Q äº†å—ï¼Ÿâ€
*   ä¸‹å±è¯´ï¼šâ€œçœ‹åˆ°äº† Pï¼â€ -> è¿”å› Pã€‚
*   ä¸‹å±è¯´ï¼šâ€œæ²¡çœ‹åˆ°ã€‚â€ -> è¿”å› Noneã€‚
*   å¦‚æœä½ å·¦æ‰‹è¾¹çš„ä¸‹å±è¯´â€œæœ‰ Pâ€ï¼Œå³æ‰‹è¾¹çš„ä¸‹å±è¯´â€œæœ‰ Qâ€ï¼Œé‚£ä½ è‡ªå·±å°±æ˜¯**æœ€è¿‘å…¬å…±ç¥–å…ˆ**ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 1. ç»ˆæ­¢æ¡ä»¶ï¼šè¶Šç•Œï¼Œæˆ–è€…æ‰¾åˆ°äº† p æˆ– q
        if not root or root == p or root == q:
            return root
        
        # 2. é€’å½’å·¦å³å­æ ‘
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        # 3. åˆ¤æ–­ç»“æœ
        if left and right:
            return root # å·¦å³å„æ‰¾åˆ°ä¸€ä¸ªï¼Œæˆ‘æ˜¯ç¥–å…ˆ
        
        if left:
            return left # åªæœ‰å·¦è¾¹æ‰¾åˆ°äº†ï¼Œå¾€ä¸Šä¼ 
        return right    # åªæœ‰å³è¾¹æ‰¾åˆ°äº†ï¼Œå¾€ä¸Šä¼ 
```

---

### 15. [1] ä¸¤æ•°ä¹‹å’Œ
*   **éš¾åº¦**ï¼šç®€å•
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šå“ˆå¸Œè¡¨

#### ğŸ’¡ é€šä¿—æ¯”å–»
**ç›¸äº²ç™»è®°**ã€‚
ä½ æ‹¿ç€å·ç ç‰Œ `x` è¿›åœºã€‚
ä½ å»ç™»è®°å¤„ï¼ˆå“ˆå¸Œè¡¨ï¼‰æŸ¥ï¼šâ€œæœ‰æ²¡æœ‰ä¸€ä¸ªå« `target - x` çš„äººæ¥è¿‡ï¼Ÿâ€
*   æœ‰ï¼šé…å¯¹æˆåŠŸï¼Œå¸¦èµ°ã€‚
*   æ²¡æœ‰ï¼šæŠŠè‡ªå·±çš„å·ç  `x` å’Œåº§ä½å· `i` ç™»è®°åœ¨è¡¨ä¸Šï¼Œç­‰æœ‰ç¼˜äººã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i, num in enumerate(nums):
            need = target - num
            if need in dic:
                return [dic[need], i]
            dic[num] = i
        return []
```

---

### 16. [46] å…¨æ’åˆ—
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šå›æº¯ (Backtracking)

#### ğŸ’¡ é€šä¿—æ¯”å–»
**å¡«ç©ºé¢˜**ã€‚
æœ‰ N ä¸ªç©ºä½ï¼ŒN å¼ æ•°å­—å¡ç‰‡ã€‚
ç¬¬ä¸€ä¸ªç©ºä½å¯ä»¥å¡« 1, 2, ... Nã€‚
å¡«äº† 1 ä¹‹åï¼Œç¬¬äºŒä¸ªç©ºä½åªèƒ½å¡«å‰©ä¸‹çš„ã€‚
å¡«é”™äº†æˆ–è€…å¡«å®Œäº†ï¼Œå°±æŠŠå¡ç‰‡æ‹¿å›æ¥ï¼ˆæ’¤é”€é€‰æ‹©ï¼‰ï¼Œæ¢ä¸€å¼ å¡«ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        
        def backtrack(nums, path):
            # ç»“æŸæ¡ä»¶ï¼šå¡«æ»¡äº†
            if len(path) == len(nums):
                res.append(path[:]) # æ³¨æ„è¦æ‹·è´ä¸€ä»½
                return
            
            for num in nums:
                if num not in path: # å¦‚æœæ²¡ç”¨è¿‡
                    path.append(num) # åšé€‰æ‹©
                    backtrack(nums, path) # é€’å½’
                    path.pop() # æ’¤é”€é€‰æ‹©
                    
        backtrack(nums, path)
        return res
```

---

### 17. [53] æœ€å¤§å­æ•°ç»„å’Œ
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šåŠ¨æ€è§„åˆ’ (Kadane)

#### ğŸ’¡ é€šä¿—æ¯”å–»
**è´Ÿé‡å‰è¡Œ**ã€‚
ä½ æ˜¯ä¸€ä¸ªæ—…è¡Œè€…ï¼Œæ²¿é€”æ¡é‡‘å¸ï¼ˆæ­£æ•°ï¼‰æˆ–è¸©å‘ï¼ˆè´Ÿæ•°ï¼‰ã€‚
æ¯åˆ°ä¸€ä¸ªæ–°åœ°ç‚¹ï¼Œä½ éƒ½è¦åšä¸€ä¸ªå†³å®šï¼š
*   **ç»§æ‰¿ä¹‹å‰çš„è´¢å¯Œ**ï¼šå¦‚æœä¹‹å‰çš„ç´¯ç§¯æ˜¯æ­£çš„ï¼Œé‚£å°±åŠ ä¸Šå®ƒï¼Œè®©è‡ªå·±æ›´å¯Œæœ‰ã€‚
*   **é‡æ–°å¼€å§‹**ï¼šå¦‚æœä¹‹å‰çš„ç´¯ç§¯æ˜¯è´Ÿçš„ï¼ˆæ¬ å€ºäº†ï¼‰ï¼Œé‚£è¿˜ä¸å¦‚æ‰”æ‰åŒ…è¢±ï¼Œä»å½“å‰è¿™ä¸ªåœ°ç‚¹é‡æ–°å¼€å§‹è®¡ç®—ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        cur_sum = 0
        max_sum = float('-inf')
        
        for num in nums:
            if cur_sum < 0:
                cur_sum = num # å¦èµ·ç‚‰ç¶
            else:
                cur_sum += num # ç»§æ‰¿è´¢å¯Œ
            
            max_sum = max(max_sum, cur_sum)
            
        return max_sum
```

---

### 18. [160] ç›¸äº¤é“¾è¡¨
*   **éš¾åº¦**ï¼šç®€å•
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šåŒæŒ‡é’ˆæ‹¼æ¥

#### ğŸ’¡ é€šä¿—æ¯”å–»
**ä½ çš„åå­—**ã€‚
ä¸¤äººåœ¨ä¸åŒçš„æ—¶é—´çº¿ï¼ˆé“¾è¡¨ï¼‰ä¸Šè·‘ã€‚
A è·‘å®Œè‡ªå·±çš„è·¯ï¼Œå»è·‘ B çš„è·¯ã€‚
B è·‘å®Œè‡ªå·±çš„è·¯ï¼Œå»è·‘ A çš„è·¯ã€‚
å¦‚æœä»–ä»¬æœ‰ç¼˜ï¼ˆç›¸äº¤ï¼‰ï¼Œå› ä¸º `len(A) + len(B) == len(B) + len(A)`ï¼Œä»–ä»¬æœ€åä¸€å®šä¼šåœ¨ç»ˆç‚¹ï¼ˆäº¤ç‚¹ï¼‰ç›¸é‡ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        if not headA or not headB: return None
        
        pA, pB = headA, headB
        
        # åªè¦æ²¡ç›¸é‡ï¼Œå°±ä¸€ç›´è·‘
        while pA != pB:
            # A è·‘å®Œäº†å»è·‘ Bï¼Œå¦åˆ™è·‘ä¸‹ä¸€æ­¥
            pA = pA.next if pA else headB
            # B è·‘å®Œäº†å»è·‘ Aï¼Œå¦åˆ™è·‘ä¸‹ä¸€æ­¥
            pB = pB.next if pB else headA
            
        return pA # ç›¸é‡ç‚¹ï¼Œæˆ–è€…éƒ½æ˜¯ None (ä¸ç›¸äº¤)
```

---

### 19. [31] ä¸‹ä¸€ä¸ªæ’åˆ—
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šæ•°å­¦è§„å¾‹ / å­—å…¸åº

#### ğŸ’¡ é€šä¿—æ¯”å–»
**æŸ¥å­—å…¸**ã€‚
ç»™ä½ ä¸€ä¸ªæ•°å­— `123`ï¼Œé—®ä½ ç”¨è¿™ä¸‰ä¸ªæ•°å­—ç»„æˆçš„æ•°é‡Œï¼Œæ¯” `123` å¤§ä¸€ç‚¹ç‚¹çš„é‚£ä¸ªæ•°æ˜¯è°ï¼Ÿï¼ˆæ˜¯ `132`ï¼‰ã€‚
æ€ä¹ˆæ‰¾â€œå¤§ä¸€ç‚¹ç‚¹â€ï¼Ÿ
1.  **å°½é‡ä¸åŠ¨é«˜ä½**ï¼šä»åå¾€å‰æ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªâ€œæ‰ä¸‹æ¥â€çš„æ•°å­—ï¼ˆå°æ•°ï¼‰ã€‚
2.  **æ‰¾ä¸ªç¨å¾®å¤§ç‚¹çš„æ›¿æ¢å®ƒ**ï¼šåœ¨åé¢æ‰¾ä¸€ä¸ªæ¯”å®ƒå¤§ä¸€ç‚¹ç‚¹çš„æ•°ï¼Œäº¤æ¢ã€‚
3.  **åé¢å˜æœ€å°**ï¼šäº¤æ¢åï¼ŒæŠŠåé¢çš„æ•°å­—å…¨éƒ¨å˜æˆå‡åºï¼ˆæœ€å°ï¼‰ï¼Œè¿™æ ·æ•´ä½“æ‰å¢åŠ å¾—æœ€å°‘ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        n = len(nums)
        i = n - 2
        
        # 1. ä»åå¾€å‰æ‰¾ç¬¬ä¸€ä¸ªå‡åºå¯¹ (i, i+1)ï¼Œæ­¤æ—¶ nums[i] å°±æ˜¯é‚£ä¸ªâ€œå°æ•°â€
        while i >= 0 and nums[i] >= nums[i+1]:
            i -= 1
            
        if i >= 0:
            # 2. ä»åå¾€å‰æ‰¾ç¬¬ä¸€ä¸ªæ¯” nums[i] å¤§çš„æ•°
            j = n - 1
            while j >= 0 and nums[j] <= nums[i]:
                j -= 1
            # äº¤æ¢
            nums[i], nums[j] = nums[j], nums[i]
            
        # 3. åè½¬ i ä¹‹åçš„æ‰€æœ‰æ•°å­—ï¼Œè®©å®ƒä»¬å˜æœ€å°
        left, right = i + 1, n - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```

---

### 20. [300] æœ€é•¿ä¸Šå‡å­åºåˆ— (LIS)
*   **éš¾åº¦**ï¼šä¸­ç­‰
*   **æ ¸å¿ƒæ¨¡å¼**ï¼šåŠ¨æ€è§„åˆ’

#### ğŸ’¡ é€šä¿—æ¯”å–»
**æ’é˜Ÿ**ã€‚
`dp[i]` ä»£è¡¨ä»¥ç¬¬ `i` ä¸ªäººç»“å°¾çš„æœ€é•¿é˜Ÿä¼é•¿åº¦ã€‚
ç¬¬ `i` ä¸ªäººå›å¤´çœ‹å‰é¢çš„äºº `j`ã€‚
å¦‚æœ `nums[i] > nums[j]`ï¼Œè¯´æ˜æˆ‘å¯ä»¥æ’åœ¨ `j` åé¢ã€‚
æˆ‘å°±æŒ‘ä¸€ä¸ªå‰é¢é˜Ÿä¼æœ€é•¿çš„ `j`ï¼Œæ’åœ¨ä»–åé¢ï¼Œé•¿åº¦ +1ã€‚

#### ğŸ’» è¯¦ç»†ä»£ç 
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums: return 0
        # dp[i] è¡¨ç¤ºä»¥ nums[i] ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦
        dp = [1] * len(nums)
        
        for i in range(len(nums)):
            for j in range(i):
                # å¦‚æœæˆ‘æ¯”å‰é¢çš„ j å¤§ï¼Œæˆ‘å¯ä»¥æ¥åœ¨ä»–åé¢
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
                    
        return max(dp)
```
