# 🚀 LeetCode 面试突击生存指南 (Top 20 高频题)

这份文档专为**时间紧迫**的面试准备设计。我不讲复杂的数学证明，只讲**核心逻辑、通俗比喻**和**万能模板**。

---

## 📚 目录

1.  **链表篇** (206, 25, 160) - 指针的艺术
2.  **数组与双指针篇** (1, 15, 42, 121, 54, 31) - 左右夹击与贪心
3.  **滑动窗口篇** (3) - 伸缩自如的窗口
4.  **树与图篇** (103, 200, 236) - DFS与BFS的舞步
5.  **搜索与排序篇** (33, 215) - 二分与堆
6.  **动态规划篇** (53, 5, 300) - 状态转移
7.  **回溯篇** (46) - 穷举的智慧
8.  **设计篇** (146) - 数据结构的组合

---

## 🔗 第一章：链表篇 (Linked List)

### 1. [206] 反转链表 (Easy)
*   **核心知识点**：双指针 (`pre`, `curr`)
*   **通俗解释**：
    想象一排人手拉手向右看。你要让他们一个个向后转。
    你需要三个角色：`pre` (前任), `curr` (当前), `next` (后任)。
    **口诀**：存下个，指前个，挪前个，挪下个。
*   **万能模板**：
    ```python
    def reverseList(head):
        pre = None
        curr = head
        while curr:
            next_node = curr.next # 1. 存下个
            curr.next = pre       # 2. 指前个
            pre = curr            # 3. 挪前个
            curr = next_node      # 4. 挪下个
        return pre
    ```
*   **举一反三**：所有链表反转题的基础。

### 2. [25] K 个一组翻转链表 (Hard)
*   **核心知识点**：反转链表 + 递归/迭代 + Dummy Node
*   **通俗解释**：
    这就是“反转链表”的批发版。把长链表切成一段段长度为 K 的小链表，每一段都调用上面的 `reverse`，然后再把它们接起来。
    **关键**：上一组的尾巴，是下一组的头的前驱。
*   **详细思路**：
    1.  用 `dummy` 节点简化头节点操作。
    2.  用 `end` 指针先走 K 步，找到这一组的结尾。
    3.  切断这一组，调用 `reverse`。
    4.  接回到主链表。
    5.  重置指针，继续下一组。
*   **举一反三**：遇到“复杂链表操作”，先想 Dummy Node，再想“切断-处理-重连”的模块化思维。

### 3. [160] 相交链表 (Easy)
*   **核心知识点**：双指针 (走过彼此的路)
*   **通俗解释**：
    你走你的路，我走我的路。如果你走完了，就去走我的路；如果我走完了，就去走你的路。
    这样我们走的总路程是一样的（A+B = B+A）。如果我们有缘（相交），最后一定会在交点相遇。
*   **万能模板**：
    ```python
    pA, pB = headA, headB
    while pA != pB:
        pA = pA.next if pA else headB
        pB = pB.next if pB else headA
    return pA
    ```

---

## ⚔️ 第二章：数组与双指针篇 (Array & Two Pointers)

### 4. [1] 两数之和 (Easy)
*   **核心知识点**：哈希表 (HashMap)
*   **通俗解释**：
    拿着一个数 `x`，去哈希表里问：“有没有人是 `target - x`？”
    如果有，配对成功；如果没有，把自己登记到哈希表里，等后面的人来找。
*   **万能模板**：
    ```python
    dic = {}
    for i, num in enumerate(nums):
        if target - num in dic:
            return [dic[target - num], i]
        dic[num] = i
    ```

### 5. [15] 三数之和 (Medium)
*   **核心知识点**：排序 + 双指针
*   **通俗解释**：
    先**排序**（为了去重和移动指针）。
    固定老大 `i`，然后在剩下的队伍里找老二 `left` 和老三 `right`。
    如果和大了，`right` 往左缩；如果和小了，`left` 往右扩。
*   **关键点**：**去重**！老大如果和上一个一样，跳过；找到答案后，老二老三如果和下一个一样，也要跳过。

### 6. [42] 接雨水 (Hard)
*   **核心知识点**：双指针 (左右夹逼)
*   **通俗解释**：
    每个柱子能装多少水，取决于它**左边最高的墙**和**右边最高的墙**里**较矮**的那一个。
    维护 `left_max` 和 `right_max`。
    谁矮谁就结算：如果 `left_max < right_max`，那左边这个柱子的水位就是 `left_max - height[left]`。
*   **举一反三**：遇到“木桶效应”或“左右边界限制”的问题，考虑双指针两边往中间缩。

### 7. [121] 买卖股票的最佳时机 (Easy)
*   **核心知识点**：贪心 / 动态规划
*   **通俗解释**：
    假设你有时光机。你只需要记录**历史最低价**。
    每天都算一下：“如果我是在历史最低点买的，今天卖能赚多少？”
    记录下这个最大利润。
*   **万能模板**：
    ```python
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    ```

### 8. [54] 螺旋矩阵 (Medium)
*   **核心知识点**：模拟 (设定边界)
*   **通俗解释**：
    就像剥洋葱，一层一层往里剥。
    设定四个边界：`top`, `bottom`, `left`, `right`。
    顺序：左->右，上->下，右->左，下->上。
    每走完一条边，就把对应的边界往里缩一格。
*   **注意**：在 `右->左` 和 `下->上` 的时候，要检查边界是否已经撞上了（`if top <= bottom`）。

### 9. [31] 下一个排列 (Medium)
*   **核心知识点**：数组操作 (字典序)
*   **通俗解释**：
    怎么让一个数字变大一点点？
    1.  **找小数**：从后往前找，找到第一个**下降**的数字 `i` (比如 `1 2 3 8 5 7 6 4` 中的 `5`)。
    2.  **找大数**：从后往前找，找到第一个比 `i` 大的数字 `j` (是 `6`)。
    3.  **交换**：交换 `5` 和 `6` (`1 2 3 8 6 7 5 4`)。
    4.  **翻转**：把 `i` 后面的所有数字翻转（变成升序，最小），这样才增加得最少。

---

## 🪟 第三章：滑动窗口篇 (Sliding Window)

### 10. [3] 无重复字符的最长子串 (Medium)
*   **核心知识点**：滑动窗口 + 哈希集合
*   **通俗解释**：
    维护一个窗口 `[left, right]`，保证窗口里没有重复字符。
    `right` 拼命往右跑（进窗口），如果发现重复字符，`left` 就慢慢往右缩（出窗口），直到重复字符消失。
    每次移动 `right` 都更新一下最大长度。
*   **万能模板**：
    ```python
    window = set()
    left = 0
    max_len = 0
    for right in range(len(s)):
        while s[right] in window:
            window.remove(s[left])
            left += 1
        window.add(s[right])
        max_len = max(max_len, right - left + 1)
    ```

---

## 🌲 第四章：树与图篇 (Tree & Graph)

### 11. [103] 二叉树的锯齿形层次遍历 (Medium)
*   **核心知识点**：BFS (队列) + 标志位
*   **通俗解释**：
    就是标准的层序遍历 (BFS)。
    加一个开关 `is_left_to_right`。
    如果是 `False`，就把这一层的结果 `reverse` 一下再存进去。
    每层结束开关取反。

### 12. [200] 岛屿数量 (Medium)
*   **核心知识点**：DFS (沉岛思想)
*   **通俗解释**：
    遍历网格，只要看到陆地 `1`，岛屿数量 +1。
    然后立刻启动 DFS，把这块陆地以及和它相连的所有陆地都**炸沉**（变成 `0`），防止后面重复计算。
*   **万能模板 (DFS)**：
    ```python
    def dfs(grid, r, c):
        if not in_area(r, c) or grid[r][c] == '0': return
        grid[r][c] = '0' # 沉岛
        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)
    ```

### 13. [236] 二叉树的最近公共祖先 (Medium)
*   **核心知识点**：递归 (后序遍历)
*   **通俗解释**：
    在树里找 `p` 和 `q`。
    *   如果当前节点是 `p` 或 `q`，就返回自己（告诉上面“我找到了”）。
    *   如果左子树找到了，右子树也找到了，那当前节点就是**公共祖先**。
    *   如果只有一边找到了，那就把找到的结果往上传。

---

## 🔍 第五章：搜索与排序篇 (Search & Sort)

### 14. [33] 搜索旋转排序数组 (Medium)
*   **核心知识点**：二分查找 (Binary Search)
*   **通俗解释**：
    数组被切了一刀。二分的时候，`mid` 切下去，一定有一半是有序的，另一半是乱序的。
    **策略**：
    1.  先看哪一半是有序的（通过比较 `nums[left]` 和 `nums[mid]`）。
    2.  如果 `target` 在有序的那一半里，就去那边找。
    3.  否则，去乱序的那一半找。

### 15. [215] 数组中的第K个最大元素 (Medium)
*   **核心知识点**：堆 (Heap) 或 快速选择 (QuickSelect)
*   **通俗解释 (堆解法)**：
    建立一个容量为 `K` 的**小顶堆**。
    遍历数组，把数字扔进去。如果堆满了，就把堆顶（最小的那个）踢出去。
    最后堆顶就是第 K 大的数（因为比它大的都在堆里，比它小的都被踢了）。
*   **代码**：`heapq.nlargest(k, nums)[-1]` 或者维护大小为 k 的堆。

---

## 📈 第六章：动态规划篇 (Dynamic Programming)

### 16. [53] 最大子数组和 (Medium)
*   **核心知识点**：DP (Kadane算法)
*   **通俗解释**：
    走到今天，是选择**继承昨天的资产**（加上前面的和），还是**另起炉灶**（从自己开始）？
    如果前面的和是负数，那就拖累我了，不如从自己开始。
    `dp[i] = max(nums[i], dp[i-1] + nums[i])`

### 17. [5] 最长回文子串 (Medium)
*   **核心知识点**：中心扩散法
*   **通俗解释**：
    遍历字符串，以每个字符为中心，向两边扩散。
    如果左边等于右边，就继续扩；否则停止。
    **注意**：中心可能是一个字符（`aba`），也可能是两个字符（`abba`）。

### 18. [300] 最长上升子序列 (Medium)
*   **核心知识点**：DP
*   **通俗解释**：
    `dp[i]` 表示以 `nums[i]` **结尾**的最长上升子序列长度。
    怎么算 `dp[i]`？
    回头看 `0` 到 `i-1` 的所有数字 `j`。如果 `nums[i] > nums[j]`，说明我可以接在 `j` 后面，长度就是 `dp[j] + 1`。
    挑一个最大的。

---

## 🌲 第七章：回溯篇 (Backtracking)

### 19. [46] 全排列 (Medium)
*   **核心知识点**：回溯模板
*   **通俗解释**：
    做选择 -> 递归 -> 撤销选择。
    想象手里有几张牌，你要把它们排成一列。
    先选一张放第一个位置，剩下的牌去排后面的位置。排完后，把这张牌收回来，换一张牌放第一个位置。
*   **万能模板**：
    ```python
    def backtrack(path):
        if len(path) == len(nums):
            res.append(path[:])
            return
        for num in nums:
            if num not in path:
                path.append(num)
                backtrack(path)
                path.pop()
    ```

---

## 🏗️ 第八章：设计篇 (Design)

### 20. [146] LRU 缓存机制 (Medium)
*   **核心知识点**：哈希表 + 双向链表
*   **通俗解释**：
    我们要实现一个“最近最少使用”的淘汰策略。
    *   **哈希表**：为了 $O(1)$ 找到节点。
    *   **双向链表**：为了 $O(1)$ 移动节点（把刚用过的移到头部，把最久没用的从尾部删掉）。
    **关键操作**：
    *   `get`：如果存在，返回值，并把它**移动到链表头部**。
    *   `put`：如果存在，更新值，移到头部。如果不存在，插到头部。如果满了，**删除链表尾部**。

---

## 💡 考前最后叮嘱

1.  **不要死记硬背代码**，要记**物理图像**（比如链表反转的“转身”，接雨水的“木桶”）。
2.  **遇到难题不要慌**：
    *   求最值 -> DP 或 贪心
    *   求所有解 -> 回溯
    *   连通性/岛屿 -> DFS/BFS
    *   数组找数 -> 二分 或 双指针
3.  **先写伪代码**：面试时先跟面试官说思路，思路对了，代码有点小 bug 也没事。
4.  **边界条件**：永远记得检查 `if not root:`, `if not nums:`, `len(nums) == 0`。

祝你面试顺利！全过！🚀
